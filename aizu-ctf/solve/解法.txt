
　愚直にやるとき

　dp[ 最初に選んだラッキーナンバー:a ] [ 今なん日:day ] [ その日のラッキーナンバー:c ]
					= a から始まって day 日後のラッキーナンバーがcになる組み合わせは何通りか

　で dp すると各々のクエリへの解答が各配列の答えになる。
　（ simple_honesty.cpp )

　だが、N=5000, M = 5000 なので配列のサイズの時点で 5000^3 でけっこーやばい。
　計算量にいたっては、状態数 ×　遷移数　で O(N^3*M) = 5000^4 = 625000000000000 でちょーやばい。

　ので、工夫する。



 求めたい入力の制約が
 ・N = 5000
 ・K = 5
 で固定であることを利用する。（正確には ((N-1)/K)%2==1 で且つ N%K==0 あることを利用する)

 この条件だと嬉しい事がある。

 例えばN=6,K=2の時

今日　次の日
 0 -> 0
 0 -> 1
 0 -> 4
 0 -> 5
 
 1 -> 1
 1 -> 2
 1 -> 5
 1 -> 0

 2 -> 2
 2 -> 3
 2 -> 0
 2 -> 1

 3 -> 3
 3 -> 4
 3 -> 1
 3 -> 2

 4 -> 4
 4 -> 5
 4 -> 2
 4 -> 3

 5 -> 5
 5 -> 6
 5 -> 3
 5 -> 4

といふうに数字の遷移が綺麗に一周していて規則正しく並んでいる。

こうなることでdpの高速化や求めるべき値の圧縮ができる。

 まず、
 0日目のラッキーナンバーが0のときにおける
 dp[今何日目:i][今日の数字:j] = 0から始まってi日後のラッキーナンバーがjになる組み合わせは何通りか
 を求める。（これについてはexcelに詳しい解説)

 次にQ個のクエリに対して考えると
 上記のdpで、最初のラッキーナンバー a = 0 の時の b日後のラッキーナンバーがcとなる組み合わせが

 dp[b][c]　に求まっている。

 もう一度、遷移の規則について観察してみると
 1 から出ている遷移は　0 から出ている遷移を一個ずつずらしただけということに気づく。

 よって、a=1のときはa=0の結果を一個ずつずらして考えればOKとなる。
 a=2,3,...N-1 のときも同様に a=0 の結果を 2,3,...N 個ずらして考えればOKなので

 dp[b][(c+N-a)%N] 

が　クエリへの解答となる。


フラグを創るためにこれらのクエリの解答を全て二乗して足し算すればOK

MODの処理を忘れずに。


 ( 絵つきの解説スライドみたいなのは後々あげます）
